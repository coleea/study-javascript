# 프로미스 (promise)

#### Q. 프라미스가 무엇인가 ?\
A. 프라미스는 약속이다. 약속에는 두가지 특징이 있다
1. 약속은 지금 일어날 일을 약속하지 않으며 미래에 일어날 일을 약속한다
1. 약속은 지킬 수도 있으며 지키지 않을 수도 있다
따라서 프라미스란 미래에 일어날 일을 예약하며 이 작업은 성공적으로 수행될 수도 있고 실패할 수도 있다\
\
프라미스의 구문은 아래와 같다
```javascript
new Promise(executor)
```

Promise생성자는 실행자(executor) 함수를 인자로 받는다. 이 실행자 함수는 리졸브(resolve)함수와 리젝트(reject)함수를 파라메터로 가진다. 즉 아래와 같다

```javascript
function executor(resolve, reject){
}
```

이게 리졸버함수의 기본 골격이다. 두개의 파라메터는 작업이 완료되었거나 작업이 실패했다는 신호를 알리는 용도로 사용된다.\
리졸브 함수가 호출되는 순간 작업이 마무리되었다는 신호를 프로미스 객체에 전달한다. 즉 아래와 같다

```javascript
function executor(resolve, reject){
    resolve()
}
```

위처럼 리졸브(resolve)함수가 호출되면 프라미스 객체의 상태가 'pending'에서 'fulfilled' 상태로 전환된다
반면 아래의 예를 보자
```javascript
function 리졸버_함수(resolve, reject){
    reject()
}
```
위처럼 리젝트(reject)함수가 호출되면 프라미스 객체의 상태가 'pending'에서 'rejected' 상태로 전환된다
정리하면, 프라미스 객체는 내부 상태를 가지며 기본 상태값은 pending이다. 이 상태는 리졸브 함수나 리젝트 함수를 호출함으로서 변경된다.\
\
##### Q. new Promise(executor)를 호출했을 때의 정확한 실행 루틴이 어떻게 되는가 ?
A. 일단 new키워드는 생성자 함수를 호출한다는 뜻이다. 즉 프라미스라는 생성자 함수를 호출하는 것인데 내부 코드가 `[native code]`라서 내부 구조를 살펴볼 수는 없다. 그러나 실행흐름을 어느정도 유추하는 것은 가능하다. 먼저 생성자 함수 내부에서 인자로 넘겨받은 실행자(executor)함수가 호출될 것이다. 이 실행자 함수 내부에서 리졸브(resolve)함수 또는 리젝트(reject)함수가 호출되면 프라미스 객체 내부에서 상태를 관장하는 프로퍼티 값이 바뀔 것이다. 그리고 프라미스 객체인 자기 자신을 리턴한다.

##### Q. 프라미스 객체는 왜 상태를 가지는가\
A. 상태를 기반으로 이어질 서브루틴을 언제 실행할지 그 타이밍을 정할 수 있기 때문이다. fetch함수의 예를 들어보면 이 함수는 특정 URL로부터 데이터를 요청한다. 데이터를 응답받은 후에 받아온 데이터를 기반으로 후속 작업을 수행할 텐데 데이터를 가져오는 타이밍이 네트워크 환경마다 다르고 서버마다 다르다. 그래서 0.1초 뒤라던지 1초후라던지 어떤 특정한 타이밍으로 고정할 수 없다. 넉넉잡아서 100초 후라고 설정할 수는 있다. 하지만 100초후에 후속작업을 수행하면 프로그램이 너무 느려진다. 이상적인 것은 네트워크 요청을 받자마자 수행하는 것인데 이는 `상태`라는 개념을 이용하면 효과적으로 달성할 수 있다. \
\
##### Q. 구체적으로 `상태`를 어떻게 활용해서 즉각적으로 후속 서브루틴을 수행하는가?\
A. 먼저 잡 스케줄러라는 개념을 이해할 필요가 있다. 잡 스케줄러는 자바스크립트 엔진에서 관리하는 함수인데 이는 앞으로 실행할 서브루틴을 스케줄링한다. 사실 자바스크립트 엔진이 관리하지 않을 수도 있지만 사소한 문제이니 넘어가자. 아무튼 프라미스는 이 잡 스케줄러를 이용한다. 즉 상태가 펜딩(pending)에서 퓰필드(fulfilled)로 바뀌거나 리젝트(reject)로 바뀌면 이 잡 스케줄러에 후속 서브루틴이 예약된다. 사실 한가지 조건이 더 있기는 한데 지금은 넘어가자. 아무튼 그렇게 후속 서브루틴은 자바스크립트의 실행 흐름이 종료되면 먼저 실행될 순서에 맞추어 하나씩 순서대로 실행된다. 이러한 잡 스케줄러를 마이크로테스큐 큐(microtask queue)라고도 한다\
\
##### Q. 잡 스케줄러에 등록되는 조건이 구체적으로 어떻게 되는가?
A. 먼저 위에서 이야기했던 것처럼 상태가 펜딩(pending)에서 퓰필드(fulfilled)로 바뀌거나 리젝트(reject)로 바뀌어야 한다. 또 하나의 조건은 프라미스 객체에서 then메소드를 호출해야 한다. 이 두가지 조건 중 하나라도 부족하다면 잡 스케줄러에 등록되지 않는다\
\
##### Q. 덴(then) 메소드가 구체적으로 무엇인가?
A. 덴 메소드는 대략적으로 아래와 같다
```javascript
function then(함수){
 // 내부 로직. 시스템상으로 구현되어 있어서 볼 수 없음
}
```
보는 것처럼 덴 메소드는 내부 로직을 볼 수 없다. 시스템상으로 정의된 로직이기 때문이다. 그리고 `함수`를 인자로 가진다. 프라미스 객체가 퓰필드되면 후속적으로 이어서 호출될 함수이다. 이 함수의 명세는 아래와 같다
```javascript
function 함수(리졸브된_값){
    // 유저가 임의로 지정한 루틴
}
```
함수는 값을 인자로 받는다. 이 값이란 리졸브 함수가 호출될 때 인자로 넘겨진 값이다. 함수의 몸체는 유저가 임의로 정의할 수 있다 \
\
\
##### Q. 페치(fetch)도 프라미스인가?\
A. 페치 자체는 프라미스가 아니다. 하지만 페치는 프라미스 객체를 리턴한다. 만일 페치로 리턴된 프라미스 객체의 상태가 퓰필드로
전환되고, 프라미스 객체의 then메소드를 호출했다면  응답받은 값을 인자로 하는 서브루틴이 잡 스케줄러에 예약된다.\
\
##### Q. 이상한 점이 있다. 나는 페치 함수를 사용할 때 리졸버(resolver) 함수를 정의하지 않는다. 따라서 리졸브(resolve) 함수가 언제 호출될지 정의하지 않는다. 리졸브(resolve) 함수를 호출하지도 않는데 어떻게 상태가 퓰필드로 바뀔수가 있는가?\
A. 리졸버 함수를 유저가 정의하지 않았지만 페치함수 내부에 리졸버 함수가 미리 정의되어 있어서 네트워크 요청이 완료되면 리졸브 함수를 호출한다. 이 때 리졸브 함수의 인자로 네트워크 요청의 응답값이 리스폰스(Response)객체에 담겨서 전달된다. 이처럼 리졸브 함수를 호출하는 작업은 자바스크립트의 메인 스레드가 수행하지 않으며 이와 별개의 시스템 스레드가 수행한다.\
\
##### Q. 만일 프라미스에서 리졸브 함수가 두번 호출되면 어떻게 되는가? 가령
```javascript
new Promise((resolve, reject) => {
    resolve("첫번째 리졸브")
    resolve("두번째 리졸브")
})
```
위의 코드는 리졸브 함수를 두번 호출했다. 이 경우 then메소드의 인자로 어떤 값이 할당되는가 ?\
A. 최초에 호출된 리졸브 함수의 인자인 `"첫번째 리졸브"`가 then메소드의 인자로 들어가며 두번째부터 호출되는 모든 리졸브와 리젝트 함수는 무시된다. 한번 결정된 값은 변하지 않는다는 원칙으로 이해하면 쉽다
\
##### Q. 프로미스가 모나드인가?\
A. 프로미스는 모나드가 가진 성질을 가지므로 모나드와 유사하지만 모나드는 아니다\
모나드가 성립되려면 좌항등원과 결합법칙 성질을 만족해야 한다. 그러나 프라미스는 좌항등원과 결합법칙 성질을 가지지 않는다. 따라서 프라미스는 모나드라고 보기 어렵다



## async 함수와 await


async함수에서 await구문은 yield구문이므로 특정한 값을 리턴하지만 이 값을 유저 레벨에서 참조하는 것은 불가능하다. await 키워드로 리턴된 프라미스는 시스템 영역에서 관리된다
만일 await의 피연산자가 프라미스 객체가 아닐 경우 promise.resolve 함수의 인자가 된다

[여담] async await 구문은 제네레이터로 구현되어 있다.
따라서 async 함수는 이터레이터이다
async await 구문이 제네레이터로 구현되어 있지만 개발자가 실행 흐름에 대한 제어권을 가져오는 것이 불가능하다. next메소드를 호출할 수 없기 떄문이다

##### Q. async 함수가 무엇인가?
A. async함수는 함수이름 앞에 async라고 표기한 함수를 말한다. 아래와 같은 함수가 async 함수다
```javascript
async function 비동기함수(){ return 1}
```
이런 비동기 함수는 두가지 특징이 있다.
1. 무조건 promise 객체를 리턴한다
1. 함수 몸체에서 await 키워드를 사용할 수 있다

##### Q. async 함수가 무조건 프라미스 객체를 리턴한다고 했는데, 위의 예제에서는 1을 리턴했다. 1은 프라미스가 아니지 않은가?
A. 물론 위의 예제에서 리턴값인 1은 프라미스가 아니다. 즉 위의 비동기함수는 컴파일 과정에서 아래처럼 프라미스를 리턴하는 함수로 변경된다. 이건 부정확하지만 이해를 위해서 일단 이렇게 이해하고 넘어가자
```javascript
function 비동기함수(){
    return new Promise((resolve, reject) => resolve(1))
}

```
위의 예제를 보면 원래 리턴될 값인 1인 리졸브 함수의 인자로 넘어갔다\
\
##### Q. 프라미스를 리턴하는게 무슨 의미가 있는가? 위의 예제만 보면 실용성이 전혀 없어보인다\
A. 그렇다 위의 예제는 실용성이 없다. 사실 async함수는 await키워드를 사용하기 위해서 쓰는것이다\
\
##### Q. await 키워드가 뭔가?
A. await 키워드는 프라미스의 then메소드를 생략하면서 후속 서브루틴을 실행할 수 있도록 해주는 문법적 기교이다. 본래 모든 프라미스 객체는 리졸브된 후에 후속 서브루틴을 실행하려면 반드시 then메소드를 호출해야만 가능했다. 하지만 코드상으로 조금 지저분한 면이 있는 관계로 선호하지 않은 개발자가 여럿 있었다. 이에 대한 대안으로 then없이도 후속 서브루틴을 호출할 수 있는 대안으로 await 키워드가 고안되었다. await키워드는 프라미스를 일드(yield)하는 키워드이며 피연산자로 프라미스 객체가 오던 원시 타입이 오던 뭐가 오던지간에 관계없이 일관되게 프라미스를 일드한다. 여기서 일드가 나와서 이게 제네레이터인가 의아해 할 수도 있을텐데 사실 제네레이터가 맞다. 모든 async 함수는 사실 제네레이터이다. 그러므로 async 함수를 제네레이터 코드로 표현할 수 있다.
```javascript
async function 비동기함수(){
    const arg = await 'yield값' ;
    return '최종리턴값' ;
}
```
위의 함수는 컴파일 과정에서 아래와 같이 변환된다
```javascript
function * 제네레이터(){
    const arg = yield new Promise((resolve, reject) => resolve('yield값'));
    return new Promise((resolve, reject) => resolve('최종리턴값')) ;
}
```
복잡할 수 있다. 그러나 하나씩 살펴보자. 제네레이터 루틴에서 일드를 만나면 그 피연산자를 일드(yield)한다. 따라서 위의 예제에서는 `new Promise((resolve, reject) => resolve('yield값'))`를 일드한다. 일드된 값은 프라미스이고 이 프라미스가 퓰필드 되거나 리젝트 될 때까지 대기된다. 그렇게 대기하다가 만일 프라미스가 퓰필드 되거나 리젝트된다면 제네레이터의 next() 메소드를 호출한다. next 메소드의 인자로는 퓰필드 되거나 리젝트 된 값을 인자로 넣는다. 따라서 위의 예제에서는 `next('yield값')`으로 호출된다. next메소드의 인자는 yield 키워드의 오른쪽에 있는 변수에 할당된다. 만일 오른쪽에 아무런 변수가 없으면 할당되지 않는다. 위의 예제에서는 yield 오른쪽에 있는 `arg`변수에 `yield값`이 할당된다. 그리고 제네레이터가 루틴을 재개한다. 사실 이게 async함수의 전부이다. 즉 async함수는 await키워드를 만나면 프라미스 객체를 리턴하는 제네레이터이다.\
정리하면 async함수가 일반적인 제네레이터와 다른점은 크게 두가지가 있다.
1. 일반적인 제네레이터는 yield 키워드를 만나면 yield키워드의 피연산자를 리턴한다. 하지만 async 함수는 일드 키워드의 피연산자를 프라미스로 랩핑하여 리턴한다.
1. 일반적인 제네레이터는 넥스트(next)메소드를 일일이 호출해줘야 후속 서브루틴이 수행된다. 하지만 async함수는 자바스크립트 엔진 내부에서 자동적으로 최종 리턴값을 반환할 때까지 자동적으로 next 메소드를 호출한다.

##### Q. yield 키워드의 피연산자가 프라미스가 아닐경우 프라미스로 랩핑된다고 했는데, 피연산자가 프라미스인 경우에도 또다른 프라미스 객체로 랩핑되는가? 그렇다면 이중 랩핑이 아닌가?
A. yield 키워드의 피연산자가 프라미스인 경우는 또다른 프라미스로 랩핑되지 않는다. 왜냐하면 yield키워드는 순전히 프라미스라는 컨테이너 내부에 값을 담는 것이 목적이기 때문이다. 이미 프라미스라는 컨테이너에 값이 담긴 경우에는 또다시 랩핑할 필요가 없다.\
