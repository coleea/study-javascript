# javascript 관련내용

### var, let
let과 var는 저장되는 환경 레코드(environment record)의 영역이 다르다
만일 이 둘이 모두 전역 스코프에서 생성되었다고 가정해보자

```javascript
var a = 2;
console.log(window.a);

let b = 1;
console.log(window.b);

```
위의 코드에서 변수 a는 문제없이 출력된다. var로 선언된 변수는 전역변수의 프로퍼티로 저장되기 때문이다.
그러나 b는 `undefined`를 출력한다. let은 전역객체의 프로퍼티로 저장되지 않기 때문이다.

var는 객체 환경 레코드 (object environment records)에 저장된다. 환경 레코드라는 말이 어려울 수 있는데 그저 변수를 관리하는 시스템 영역이다. 그런데 왜 이름이 `객체` 환경 레코드인가 하면 간단하게 `객체안에 담기기 때문`이라고 이해하면 쉽다. 자바스크립트에는 글로벌 객체가 존재한다. 이 객체안에 프로퍼티의 일부로 변수가 저장된다
let은 선언적 환경 레코드 (declarative environment record)에 저장된다. 선언적 환경 레코드는 객체 환경 레코드와 상호 무관한 시스템 영역에서 관리된다.
이 두개의 레코드는 모두 환경 레코드(Environment Record)라는 변수를 담고있는 시스템 자원의 일부분이다. 시스템 자원이므로 자바스크립트 코드로는 직접적으로 접근할 수 없다


다른 예제를 보자

```javascript
var a = 'test'
var a = 'test2'

```
위의 예제에서 a는 같은 이름으로 재선언되었는데 아무런 문제가 발생하지 않는다.\
즉 개발자가 실수로 재선언해도 알아차리기 어렵다.\
let, const는 그런 실수를 미연에 방지해준다
```javascript
let a = 'test'
let a = 'test2'
```
위와 같이 let으로 선언된 변수를 재선언하면 에러를 출력한다\
`Uncaught SyntaxError: Identifier 'a' has already been declared`\
하지만 그게 let과 const가 생겨난 의의는 아니다. let과 const는 블록 스코프를 구현하기 위해 만들어졌다

## 변수 선언
변수를 직접 사용할 블록 스코프에 선언하는게 좋은 이유
두가지 측면에서 좋다.
1. 더이상 참조하지 않는 변수의 메모리 누수를 막아준다.
2. 변수를 참고할 때 스코프 체이닝을 시도할때 소모되는 탐색시간을 없애준다

### 객체

다음은 유효한가?
```javascript
const 객체2 = {
    [1 < 0] : 1
}
```
유효하다. 객체의 프로퍼티 이름을 지정할 때는 어떠한 종류의 표현식도 가능하기 때문이다. 위의 객체2는 `{false: 1}`를 만들어낸다
이 성질을 이용하면 if문을 사용하지 않고도 분기문을 구현할 수 있다. 아래의 예는 유저의 나이를 기반으로 성인인지 미성년인지를 구분하는 코드다
```javascript
function 성인확인창_띄우기(){ alert(`성인입니다`)}
function 미성년확인창_띄우기(){ alert(`미성년입니다`)}

const 성인나이 = 18

const 성인여부 = {
    [true] : 성인확인창_띄우기,
    [false] : 미성년확인창_띄우기,
}

const 유저 = {
    나이 : 17,
}

성인여부[유저.나이 > 성인나이]() ;
```
\
\
어떠한 종류의 표현식도 가능하기 때문에 아래도 가능하다
```javascript
function 함수 () {return 1}
const 객체 = {
    [함수] : 1
}
```
어떤 함수를 호출하지 않고 이름만 넣었을 때는 그 함수에 toString()메소드의 호출결과를 적용한다\
따라서 `객체`는 `{"function 함수 () {return 1}" : 1}`를 만들어낸다. 복잡해 보이지만 키(key)가 `"function 함수 () {return 1}"`이고 값이 1이다\
따라서 위의 객체에서 1을 참조할 때는 `객체["function 함수 () {return 1}"]`로 참조하거나 `객체[함수]`로 참조할 수 있다
함수, 배열, 객체 모두 마찬가지로 객체 프로퍼티 이름에 넣으면 그 대상에 toString()메소드의 호출결과를 적용한다\
예를들어
```javascript
const 배열 = [1,2,3,4,5]
const 객체3 ={
    [배열] : 1
}
```
객체 프로퍼티 이름에 배열을 적용했다. 따라서 배열에 toString을 적용한 `"[1,2,3,4,5]"`가 키(key)가 된다
따라서 위의 객체3에서 1을 참조할 때는 `객체3["[1,2,3,4,5]"]`으로 참조하거나 `객체3[배열]`로 참조할 수 있다
### 객체 디컨스트럭팅

```javascript
const object = {
    name : '김삿갓'
}
const {name : firstName} = object
```
위의 코드에서 아래 선언한 `firstName` 변수에 object.name의 값인 `김삿갓`이 할당된다

### 프로미스 (promise)
Q. 프라미스가 무엇인가 ?\
A. 프라미스는 약속이다. 약속에는 두가지 특징이 있다
1. 약속은 지금 일어날 일을 약속하지 않으며 미래에 일어날 일을 약속한다
1. 약속은 지킬 수도 있으며 지키지 않을 수도 있다
따라서 프라미스란 미래에 일어날 일을 예약하며 이 작업은 성공적으로 수행될 수도 있고 실패할 수도 있다\
\
프라미스의 구문은 아래와 같다
```javascript
new Promise(리졸버_함수)
```

Promise생성자는 리졸버 함수를 인자로 받는다. 이 리졸버 함수는 리졸브(resolve)함수와 리젝트(reject)함수를 파라메터로 가진다. 즉 아래와 같다

```javascript
function 리졸버_함수(resolve, reject){
}
```

이게 리졸버함수의 기본 골격이다. 두개의 파라메터는 작업이 완료되었거나 작업이 실패했다는 신호를 알리는 용도로 사용된다.\
리졸브 함수가 호출되는 순간 작업이 마무리되었다는 신호를 프로미스 객체에 전달한다. 즉 아래와 같다

```javascript
function 리졸버_함수(resolve, reject){
    resolve()
}
```

위처럼 리졸브(resolve)함수가 호출되면 프라미스 객체의 상태가 'pending'에서 'fulfilled' 상태로 전환된다
반면 아래의 예를 보자
```javascript
function 리졸버_함수(resolve, reject){
    reject()
}
```
위처럼 리젝트(reject)함수가 호출되면 프라미스 객체의 상태가 'pending'에서 'rejected' 상태로 전환된다
정리하면, 프라미스 객체는 내부 상태를 가지며 기본 상태값은 pending이다. 이 상태는 리졸브 함수나 리젝트 함수를 호출함으로서 변경된다.\
\
Q. 프라미스 객체는 왜 상태를 가지는가\
A. 상태를 기반으로 이어질 서브루틴을 언제 실행할지 그 타이밍을 정할 수 있기 때문이다. fetch함수의 예를 들어보면 이 함수는 특정 URL로부터 데이터를 요청한다. 데이터를 응답받은 후에 받아온 데이터를 기반으로 후속 작업을 수행할 텐데 데이터를 가져오는 타이밍이 네트워크 환경마다 다르고 서버마다 다르다. 그래서 0.1초 뒤라던지 1초후라던지 어떤 특정한 타이밍으로 고정할 수 없다. 넉넉잡아서 100초 후라고 설정할 수는 있다. 하지만 100초후에 후속작업을 수행하면 프로그램이 너무 느려진다. 이상적인 것은 네트워크 요청을 받자마자 수행하는 것인데 이는 `상태`라는 개념을 이용하면 효과적으로 달성할 수 있다. \
\
Q. 구체적으로 `상태`를 어떻게 활용해서 즉각적으로 후속 서브루틴을 수행하는가?\
A. 먼저 잡 스케줄러라는 개념을 이해할 필요가 있다. 잡 스케줄러는 자바스크립트 엔진에서 관리하는 함수인데 이는 앞으로 실행할 서브루틴을 스케줄링한다. 사실 자바스크립트 엔진이 관리하지 않을 수도 있지만 사소한 문제이니 넘어가자. 아무튼 프라미스는 이 잡 스케줄러를 이용한다. 즉 상태가 펜딩(pending)에서 퓰필드(fulfilled)로 바뀌거나 리젝트(reject)로 바뀌면 이 잡 스케줄러에 후속 서브루틴이 예약된다. 사실 한가지 조건이 더 있기는 한데 지금은 넘어가자. 아무튼 그렇게 후속 서브루틴은 자바스크립트의 실행 흐름이 종료되면 먼저 실행될 순서에 맞추어 하나씩 순서대로 실행된다. 이러한 잡 스케줄러를 마이크로테스큐 큐(microtask queue)라고도 한다\
\
Q. 잡 스케줄러에 등록되는 조건이 구체적으로 어떻게 되는가?
A. 먼저 위에서 이야기했던 것처럼 상태가 펜딩(pending)에서 퓰필드(fulfilled)로 바뀌거나 리젝트(reject)로 바뀌어야 한다. 또 하나의 조건은 프라미스 객체에서 then메소드를 호출해야 한다. 이 두가지 조건 중 하나라도 부족하다면 잡 스케줄러에 등록되지 않는다\
\
Q. 덴(then) 메소드가 구체적으로 무엇인가?
A. 덴 메소드는 대략적으로 아래와 같다
```javascript
function then(함수){
 // 내부 로직. 시스템상으로 구현되어 있어서 볼 수 없음
}
```
보는 것처럼 덴 메소드는 내부 로직을 볼 수 없다. 시스템상으로 정의된 로직이기 때문이다. 그리고 `함수`를 인자로 가진다. 프라미스 객체가 퓰필드되면 후속적으로 이어서 호출될 함수이다. 이 함수의 명세는 아래와 같다
```javascript
function 함수(리졸브된_값){
    // 유저가 임의로 지정한 루틴
}
```
함수는 값을 인자로 받는다. 이 값이란 리졸브 함수가 호출될 때 인자로 넘겨진 값이다. 함수의 몸체는 유저가 임의로 정의할 수 있다 \
\
\
Q. 페치(fetch)도 프라미스인가?\
A. 페치 자체는 프라미스가 아니다. 하지만 페치는 프라미스 객체를 리턴한다. 만일 페치로 리턴된 프라미스 객체의 상태가 퓰필드로
전환되고, 프라미스 객체의 then메소드를 호출했다면  응답받은 값을 인자로 하는 서브루틴이 잡 스케줄러에 예약된다.\
\
Q. 이상한 점이 있다. 나는 페치 함수를 사용할 때 리졸버(resolver) 함수를 정의하지 않는다. 따라서 리졸브(resolve) 함수가 언제 호출될지 정의하지 않는다. 리졸브(resolve) 함수를 호출하지도 않는데 어떻게 상태가 퓰필드로 바뀔수가 있는가?\
A. 리졸버 함수를 유저가 정의하지 않았지만 페치함수 내부에 리졸버 함수가 미리 정의되어 있어서 네트워크 요청이 완료되면 리졸브 함수를 호출한다. 이 때 리졸브 함수의 인자로 네트워크 요청의 응답값이 리스폰스(Response)객체에 담겨서 전달된다. 이처럼 리졸브 함수를 호출하는 작업은 자바스크립트의 메인 스레드가 수행하지 않으며 이와 별개의 시스템 스레드가 수행한다.\
\
Q. 만일 프라미스에서 리졸브 함수가 두번 호출되면 어떻게 되는가? 가령
```javascript
new Promise((resolve, reject) => {
    resolve("첫번째 리졸브")
    resolve("두번째 리졸브")
})
```
위의 코드는 리졸브 함수를 두번 호출했다. 이 경우 then메소드의 인자로 어떤 값이 할당되는가 ?\
A. 최초에 호출된 리졸브 함수의 인자인 `"첫번째 리졸브"`가 then메소드의 인자로 들어가며 두번째부터 호출되는 모든 리졸브와 리젝트 함수는 무시된다. 한번 결정된 값은 변하지 않는다는 원칙으로 이해하면 쉽다
\
Q. 프로미스가 모나드인가?\
A. 프로미스는 모나드가 가진 성질을 가지므로 모나드와 유사하지만 모나드는 아니다\
모나드가 성립되려면 좌항등원과 결합법칙 성질을 만족해야 한다. 그러나 프라미스는 좌항등원과 결합법칙 성질을 가지지 않는다. 따라서 프라미스는 모나드라고 보기 어렵다


## 제네레이터
Q. 제네레이터의 next() 메소드의 인자를 넘겨주면 어떻게 처리되는가?\
A. 넥스트 메소드의 인자는 yield 구문의 위치에 값이 들어가며 만일 yield가 할당문의 오른쪽에 있다면 값이 할당된다. 예를 들어
`const nextArgPassed  = yield ; `\
위의 구문에서 next()메소드에 `5`라는 값을 넘겨주었다면 제네레이터가 실행되면서 yield 구문의 위치에 값이 들어간다. 따라서 `const nextArgPassed  = 5 ; `가 되고   `nextArgPassed` 변수에 5가 할당된다\
\
제네레이터는 본래 화살표 함수처럼 화살표 제네레이터도 논의되었다\
arrow 제네레이터는 2번이상 논의되었으나 일관성있는 구문을 만들어내는데 실패했다\
Arrow generators were discussed more than once, but nobody was able to come up with a syntax that was consistent and didn't have problems\
-- 안드레아스 로스버그\
여담으로 async함수는 제네레이터로 구현되었다


## async 함수와 await
Q. async 함수가 무엇인가?
A. async함수는 함수이름 앞에 async라고 표기한 함수를 말한다. 아래와 같은 함수가 비동기 함수다
```javascript
async function 비동기함수(){ return 1}
```
이런 비동기 함수는 두가지 특징이 있다.
1. 무조건 promise 객체를 리턴한다
1. 함수 몸체에서 await 키워드를 사용할 수 있다

Q. async 함수가 무조건 프라미스 객체를 리턴한다고 했는데, 위의 예제에서는 1을 리턴했다. 1은 프라미스가 아니지 않은가?
A. 물론 위의 예제에서 리턴값인 1은 프라미스가 아니다. 즉 위의 비동기함수는 컴파일 과정에서 아래처럼 프라미스를 리턴하는 함수로 변경된다. 이건 부정확하지만 이해를 위해서 일단 이렇게 이해하고 넘어가자
```javascript
function 비동기함수(){
    return new Promise((resolve, reject) => resolve(1))
}

```
위의 예제를 보면 원래 리턴될 값인 1인 리졸브 함수의 인자로 넘어갔다\
\
Q. 프라미스를 리턴하는게 무슨 의미가 있는가? 위의 예제만 보면 실용성이 전혀 없어보인다\
A. 그렇다 위의 예제는 실용성이 없다. 사실 async함수는 await키워드를 사용하기 위해서 쓰는것이다\
\
Q. await 키워드가 뭔가?
A. await 키워드는 프라미스의 then메소드를 생략하면서 후속 서브루틴을 실행할 수 있도록 해주는 문법적 기교이다. 본래 모든 프라미스 객체는 리졸브된 후에 후속 서브루틴을 실행하려면 반드시 then메소드를 호출해야만 가능했다. 하지만 코드상으로 조금 지저분한 면이 있는 관계로 선호하지 않은 개발자가 여럿 있었다. 이에 대한 대안으로 then없이도 후속 서브루틴을 호출할 수 있는 대안으로 await 키워드가 고안되었다. await키워드는 프라미스를 일드(yield)하는 키워드이며 피연산자로 프라미스 객체가 오던 원시 타입이 오던 뭐가 오던지간에 관계없이 일관되게 프라미스를 일드한다. 여기서 일드가 나와서 이게 제네레이터인가 의아해 할 수도 있을텐데 사실 제네레이터가 맞다. 모든 async 함수는 사실 제네레이터이다. 그러므로 async 함수를 제네레이터 코드로 표현할 수 있다.
```javascript
async function 비동기함수(){
    const arg = await 'yield값' ;
    return '최종리턴값' ;
}
```
위의 함수는 컴파일 과정에서 아래와 같이 변환된다
```javascript
function * 제네레이터(){
    const arg = yield new Promise((resolve, reject) => resolve('yield값'));
    return new Promise((resolve, reject) => resolve('최종리턴값')) ;
}
```
복잡할 수 있다. 그러나 하나씩 살펴보자. 제네레이터 루틴에서 일드를 만나면 그 피연산자를 일드(yield)한다. 따라서 위의 예제에서는 `new Promise((resolve, reject) => resolve('yield값'))`를 일드한다. 일드된 값은 프라미스이고 이 프라미스가 퓰필드 되거나 리젝트 될 때까지 대기된다. 그렇게 대기하다가 만일 프라미스가 퓰필드 되거나 리젝트된다면 제네레이터의 next() 메소드를 호출한다. next 메소드의 인자로는 퓰필드 되거나 리젝트 된 값을 인자로 넣는다. 따라서 위의 예제에서는 `next('yield값')`으로 호출된다. next메소드의 인자는 yield 키워드의 오른쪽에 있는 변수에 할당된다. 만일 오른쪽에 아무런 변수가 없으면 할당되지 않는다. 위의 예제에서는 yield 오른쪽에 있는 `arg`변수에 `yield값`이 할당된다. 그리고 제네레이터가 루틴을 재개한다. 사실 이게 async함수의 전부이다. 즉 async함수는 await키워드를 만나면 프라미스 객체를 리턴하는 제네레이터이다.\
정리하면 async함수가 일반적인 제네레이터와 다른점은 크게 두가지가 있다.
1. 일반적인 제네레이터는 yield 키워드를 만나면 yield키워드의 피연산자를 리턴한다. 하지만 async 함수는 일드 키워드의 피연산자를 프라미스로 랩핑하여 리턴한다.
1. 일반적인 제네레이터는 넥스트(next)메소드를 일일이 호출해줘야 후속 서브루틴이 수행된다. 하지만 async함수는 자바스크립트 엔진 내부에서 자동적으로 최종 리턴값을 반환할 때까지 자동적으로 next 메소드를 호출한다.

Q. yield 키워드의 피연산자가 프라미스가 아닐경우 프라미스로 랩핑된다고 했는데, 피연산자가 프라미스인 경우에도 또다른 프라미스 객체로 랩핑되는가? 그렇다면 이중 랩핑이 아닌가?
A. yield 키워드의 피연산자가 프라미스인 경우는 또다른 프라미스로 랩핑되지 않는다. 왜냐하면 yield키워드는 순전히 프라미스라는 컨테이너 내부에 값을 담는 것이 목적이기 때문이다. 이미 프라미스라는 컨테이너에 값이 담긴 경우에는 또다시 랩핑할 필요가 없다.\

## for await of

## 클로저 (Closure)
클로저는 자바스크립트에서 가장 중요한 기능 중 하나로 판명되었다.\
이것이 자바스크립트를 세계 최고의 프로그래밍 언어 중 하나로 만드는 것이다.\
-- 더글라스 크락포드

## 적절한 꼬리호출 (proper tail calls, PTC, tail call optimization)
proper tail calls 는 ES6 스펙 전체를 통틀어 가장 중요한 스펙이다\
--  더글라스 크락포드\
\
그러나 적절한 꼬리호출은 사파리 외 다른 브라우저 밴더에서 구현을 거부하였다\
(PTC has proven to be a contentious feature. It has been successfully implemented by at least one major browser engine but others have refused to support it.)

## 클래스 (class)
클래스를 사용하는 사람들은 자신이 얼마나 비참했는지도 모른 채 무덤으로 가게 될 것이다\
-- 더글라스 크락포드

## 함수 실행의 내부 작동 원리
자바스크립트에서는 함수를 호출할 때마다 함수 컨텍스트 스택에 레코드(프레임)가 생성된다.\
\
전역 컨텍스트 프레임은 항상 스택 맨 밑에 위치한다.\
함수 컨텍스트 프레임은 각각 내부 지역 변수의 개수만큼 메모리를 점유한다.\
지역변수가 하나도 없는 빈 프레임은 48바이트 정도 되고,\
숫자, 불리언 같은 지역 변수/매개변수는 8바이트를 차지한다.

## 모듈 (es module)
모듈은 ES6 스펙 중에서 가장 중요하고 가장 의미있습니다\
(Modules are the next most important and significant to address in the spec)\
-- 앨런 워프스 브록 (Allen Wirfs-Brock, ES6스펙 총책임자), 2013년 TC39 미팅 中\
\
Q. html파일에 `<script></script>` 라고 적은것과  `<script type="module"></script>`이라고 적은것은 어떤 차이가 있는가 ?\
A. 이것은 순전히 스코프의 차이다. 아무런 타입을 표기하지 않은 `<script></script>`구문으로 로드된 자바스크립트 코드의 스코프는 전역 스코프가 된다. 하지만 `<script type="module"></script>`로 로드된 자바스크립트 코드는 모듈 스코프 내에서 작동한다. 모듈 스코프는 전역 스코프와 별개의 스코프이며 변수 충돌등이 일어나지 않는다\
Module scripts are not affected by the charset and defer attributes.\
https://www.w3.org/TR/html5/semantics-scripting.html#element-attrdef-script-type\
참고 사이트 : https://html.spec.whatwg.org/multipage/webappapis.html#module-script

## 패턴매칭
결론부터 말하면 패턴 매칭을 함수호출에 적용하면  분기문을 없앨수 있다\
함수를 호출할 때 인자의 종류에 따라서 다른 함수를 호출해야 할 때가 있다\
가령 아래와 같은 코드의 경우다
```
var 도형 = 도형구하기()
if(도형 instanceof 삼각형){
  삼각형넒이(도형)
} else if(도형 instanceeof 사각형){
  사각형넒이(도형)
}    
```
위의 코드는 도형이 삼각형 객체의 인스턴스일 때 `삼각형넒이`함수를 호출하고, 사각형 객체의 인스턴스일 때는 `사각형넒이` 함수를 호출한다. 인자의 종류에 따라서 다른 함수를 호출하는 흔한 패턴이다\
위의 코드는 패턴 매칭을 사용할 경우 아래 코드로 치환될 수 있다
```
var 도형 = 도형구하기()
넒이구하기(도형)
```
두말할 것 없이 코드가 간결해졌다. 어떻게 이것이 가능한가? 여러분은 아마도 함수 오버로딩이라는 개념을 들어봤을 것이다. 함수의 이름이 같고 인자의 갯수가 다를 때는 인자의 갯수에 맞추어 각기 다른 함수가 호출된다는 개념이다. 패턴 매칭도 이와 비슷한 개념이지만 한가지 중요한 차이점이 있다\
`패턴 매칭은 인자의 갯수가 같은 경우에 발동한다`\
인자의 갯수가 같은 경우에 인자의 패턴에 따라서 각기 다른 함수를 호출한다. 그래서 이름이 패턴 매칭이다.\
위의 코드에서는 각각 인자가 삼각형객체의 인스턴스인 케이스와, 인자가 사각형객체의 인스턴스인 경우를 별도로 정의해 놓아야 한다. 예를들어 아래와 같다
```
const 넒이구하기 = (삼각형) => (삼각형.밑변 * 삼각형.높이) / 2
const 넒이구하기 = (사각형) => (사각형.x * 사각형.y)
```
패턴매칭을 구현해놓은 수도 코드이다. 각각의 라인별로 각기다른 패턴을 정의해놓은 것이고 `넒이구하기`라고 적혀진 함수이름은 헤드(head)라고 부른다. 괄호안의 인자는 패턴이라고 부른다. 마지막으로 화살표(`=>`) 오른편은 함수의 바디(body)이며 실제로 함수가 실행되는 내용이다\
이와같이 정의해 놓으면 함수를 호출할 때 맨 위에 정의해놓은 패턴부터 차례대로 패턴에 해당되는지를 체크하고 맞으면 함수의 몸체를 실행한다. 패턴에 부합하지 않으면 다음 패턴을 체크한다. 이 과정을 모든 패턴에 대하여 수행한다. 이것은 그야말로 if-else문과 완전히 똑같은 흐름이다. 하지만 패턴매칭이 if-else문과 대비되는 점은 분기문을 실행흐름 중간에 삽입하지 않아도 되며 실행흐름과 떼어놓을 수 있다는 점이다. 그렇게 얻을 수 있는 결과는 if-else같은 지저분한 분기문을 제거할 수 있게 되고 그 결과 코드가 더 깔끔하고 이해하기 쉬워진다\

js에서 패턴매칭의 구문은 `match(비교할패턴) { 표현식 }` 의 형태로 기술된다
[링크](https://hackmd.io/@mpcsh/HkZ712ig_#/4)

## 대수적 효과 (algebraic effect)
Q. 대수적 효과란 무엇인가 ?\
A. 대수적 효과는 ECMA스펙에 정식 등록된 사양은 아니다. 이 기능은 구현된 언어 자체가 거의 없다. 하지만 흥미로운 주제라서 다뤄본다.\
대수적 효과는 비순수 함수에서 부작용을 유발하는 코드부를 다른 곳으로 분리할 수 있게 해주는 문법적 도구다.\
즉 대수효과의 의의는 코드의 분리에 있다. 아래와 같은 코드를 가정해보자\
![캡처](/img/대수적효과1.png)
이 함수는 서버와 통신하는 서브루틴을 포함한다. 따라서 이 함수는 부작용을 유발한다. 이 함수 내부에서 서버와 통신하는 코드가 존재하는 한 부작용을 걷어낼 방법은 없다. 하지만 대수적 효과를 사용하면 서버와 통신하는 코드를 다른 영역으로 분리할 수 있다. 그 코드는 대략 아래와 같다
![캡처](/img/대수적효과2.png)
위의 코드에서 주목할 점은 아래 biz함수의 `try {} handle (effect) {}` 구문이다. 이는 마치 `try-catch`구문을 연상시킨다. 루틴이 다른 곳으로 점프한다는 면에서는 트라이 캐치 구문과 같다. 하지만 `try-catch`구문에서는 에러가 발생해야만 루틴이 catch 블럭으로 점프하는데 반하여 `try-handle`구문에서는 에러 발생여부와 상관없이 무조건 루틴이 핸들(handle) 블럭으로 점프한다. 핸들 내부에서 이펙트의 타입을 확인하고 각 타입에 대응하는 루틴을 수행하는 것이 보일 것이다. 위의 예제에서는 이펙트의 종류가 `getInfo`인 경우에 getInfo함수를 호출하여 서버에 데이터를 요청했다. 데이터를 요청받은 이후에는 `resume`키워드가 작동하여 핸들 블럭으로 점프하기 이전의 루틴으로 이동한다. 즉 `biz`함수의 두번째 줄로 이동한다. 그리고 `biz`함수는 재개된다. 결과적으로 대수적 효과는 `try-catch`구문과 제네레이터를 합성한 독특한 구문으로 해석할수도 있을것이다.
대수적 효과를 적용하면 async함수를 프라미스가 아닌(non-promise) 로직으로 변경할 수 있는데 이 경우 중첩된 async로 인한 오염을 방지할 수 있다
상세는 [이곳](https://www.zhihu.com/question/300095154)을 참조하시오

---

## 그 외 질문들
##### Q. 동적 타입으로서 자바스크립트가 가지는 치명적인 단점을 말해보시오

A. 자바스크립트는 컴파일 시점에 타입 체킹을 하지 않는다. 타입 불일치로 인한 오류는 런타임 환경에서 코드를 구동하면서 발견할 수 있다.
에러를 늦게 발견함으로서 개발자가 입는 시간적인 손실은 뼈아프다. 같은 오류라 하더라도 에러를 발견한 시점에 따라 디버깅에 소요되는 시간은 많은 차이를 보인다.
typescript는 이러한 단점을 보완하는 차원에서 만들어진 자바스크립트의 변형 언어이다.

##### Q. 소스를 보다보면 `<a href="javascript:"></a>`처럼 `javascript:`라는 문자열이 보인다. 이건 무슨 뜻인가 ?
A. 이것은 자바스크립트 코드를 실행하겠다는 뜻이다. 그런데 위의 예에서는 `javascript:`이후로 아무런 코드가 없다. 따라서 아무런 코드도 실행하지 않는다는 뜻이다. 그러면 의아할 수 있다. 그냥  `<a href=""></a>` 으로 표기하면 될 것을 왜 굳이 아무런 행동도 하지 않는 `javascript:`라는 코드를 집어넣은 것인가 ?  그 이유는  `<a href=""></a>` 으로 입력하면 a태그를 클릭했을 때 현재 페이지로 재접속하기 때문이다. 따라서 a태그를 입력했을 때 아무런 액션도 취하지 않게 하고 싶을 때 주로 사용하는 트릭이다.

참고 : https://stackoverflow.com/questions/20502636/what-does-javascript-do


##### Q. node.js에서 임포트할 때 `import Sidebar from '@/components/sidebar'`처럼 `골뱅이(@)`표기가  붙을 때가 있다. 이건 무슨 뜻인가 ?
A.  일단 모듈 로더는 ecma스펙이 아니다. 자바스크립트 언어의 관점에서 보면 이 모듈 식별자는 미지의 식별자이므로 당신이 사용하는 모듇 로더 또는 모듈 번들러에 전적으로 의지한다.  만일 당신이 `babel-plugin-root-import`를 사용한다면 이것은 해당 프로젝트의 루트 디렉토리를 의미한다


##### Q. 왜 자바스크립트는 호이스팅이라는 기능을 도입했는가 ?\
A. 호이스팅은 순전히 함수 때문에 생겨난 기능이다. 함수를 아래에 선언하더라도 코드 위쪽에서 호출할 수 있도록 하기 위해서 만든 개념이다. 자바스크립트의 창시자는 이런말을 했다

나는 var 호이스팅을 의도하지 않았다. 내가 원했던 것은 함수 호이스팅 이었으며 var 호이스팅은 부산물에 불과했다\
-- 브랜던 아이크\
var 호이스팅은 일종의 부작용 이었으므로 그가 ES 2015에서 let과 const라는 블럭 스코프용 변수를 만들 때는 호이스팅 기능을 제외시켰다

##### Q. 숏서킷 평가가 뭔가 ?\
A. 아래의 예를 참조하라

```javascript
const NUMBER = 10
const res = NUMBER && (NUMBER * 2)
```
위의 식에서 `&&` 연산자를 숏서킷 평가자라고 하고 `NUMBER && (NUMBER * 2)`를 숏서킷 평가라고 한다\
숏서킷 평가자(`&&`) 의 가장 오른쪽부터 순서대로 평가된다. 위의 예에서는 NUMBER라는 변수를 하나의 평가식으로 평가한다. 그 값은 10이고 이 값은 참값(truthy value)이다. 평가값이 참값일 때는 왼쪽의 평가식으로 넘어가고 만일 거짓값(falshy value)라면 그 자리에서 false를 리턴한다. 위의 예제에서 10은 참값이므로 왼쪽의 평가식으로 넘어간다. 평가식이 `(NUMBER * 2)`이므로 값은 20이 된다. 20은 참값이므로 false를 리턴하지 않고 다음 평가식으로 넘어간다. 그런데 다음 평가식이 없다. 이런 경우에는 최종 평가된 평가식을 왼쪽의 `res`변수에 할당한다. 따라서 res변수에는 20이 할당된다\
숏서킷 평가자는 앤드연산자(`&&`)와 or연산자(`||`)가 있다. 이런 숏서킷 평가 구문을 이용하면 if문을 없애고 분기문을 표현할 수 있다. 예를 들어 미성년자인 경우에 미성년자 알림 경고를 띄우는 프로그램을 작성한다고 해보자. 일반적인 경우에는 아래와 같이 작성할 수 있다

```javascript
function 미성년확인창_띄우기(){ alert(`미성년입니다`)}

const 유저 = {
    나이 : 17,
}

if(유저.나이 < 18) 미성년확인창_띄우기()
```

위의 코드를 숏서킷 평가자로 변환하면 아래와 같다

```javascript
function 미성년확인창_띄우기(){ alert(`미성년입니다`) }

const 유저 = {
    나이 : 17,
};

(유저.나이 < 18) && 미성년확인창_띄우기()
```

#####  Q. 자바스크립트에는 파이썬의 range()함수같은 기능이 없는가?\
A. 빌트인 기능은 없다. 하지만 비슷하게 구현은 할수있다\
아래를 참조하라
```javascript
(from, to) => [...Array(to - from)].map((_,i)=> i + from)
```

---

## js 런타임 환경

### setTimeout(0) 보다 빠르게 실행하는 방법이 있는가 ?
메시지채널 (MessageChannel)API의 postMessage를 사용하면 setTimeout보다 빠르게 일을 처리할 수 있다


### s A. fetch등의 Web API 함수들을 console.log로 확인해보면 `ƒ fetch() { [native code] }`라고 출력한다. 여기서 `[native code]`가 무슨 뜻인가?
A. `[native code]`란 자바스크립트 내부의 코드가 아닌 js 실행코드를 관리하는 시스템에서 구현된 코드라는 의미이다. 이처럼 모든 웹 API는 자바스크립트 내부의 코드가 아닌 js 실행코드를 컨트롤하는 시스템 내부에 구현되어 있다. 크롬 웹브라우저의 예를 들면 웹 API는 렌더러 엔진인 블링크(blink) 내부에 구현되어 있다. 이 블링크는 C++로 구현되었고 따라서 블링크 내부에 구현된 웹 API도 C++로 구현되었다. fetch등의 웹 API가 실행되면 실행 흐름이 블링크 렌더러 엔진으로 전환되고 fetch함수에 대응되는 c++코드가 실행된다. 그 코드의 리턴값을 다시 자바스크립트 코드로 가져오는 흐름이 네이티브 코드의 실행방식이다.

### s Q. fetch함수의 최종 응답객체인 리스폰스(Response) 객체에서 json메소드를 수행하면 json으로 변환된 값을 반환한다. 그런데 이 json 메소드를 다시 실행하면 에러가 발생한다.\
`Uncaught (in promise) TypeError: Failed to execute 'json' on 'Response': body stream already read`\
즉 json메소드는 한번밖에 사용할 수 없다. 그 이유가 왜인가?
A. 이것은 순전히 메모리 최적화의 일환이었다. 한 번 json메소드가 호출되면 리스폰스 객체가 가지고 있는 원본 데이터는 메모리에서 해제된다. 다시말해 리스폰스 객체는 메모리 사용을 최소화하는 방향으로 설계되었다. `json()`메소드를 호출하면 중간 객체에서의 버퍼링을 작게 유지할 수 있도록 Response 객체의 데이터를 점진적으로 소비한다.\
1메가 크기의 http 응답을 받은 뒤에 JSON 파일로 변환했다고 가정하자. Response가 `.json()` 호출 후에도 원래 리스폰스 바디 데이터를 유지하도록 설계된 경우에는 차지하는 메모리 공간이 `1메가 + 1메가 = 2메가`에 도달한다 (단순화를 위해 json 객체가 1MB라고 가정한다)\
json 객체가 생성되는 즉시 리스폰스 데이터를 해제할 수 있도록 설계하면 메모리 크기를 `소형크기의 버퍼 + 1MB` 정도로 줄일 수 있다.\
리스폰스 바디를 재사용하고 싶을 때만 클론`clone` 메소드를 사용하여 수동으로 객체를 복제할 수 있다.
[출처](https://github.com/whatwg/fetch/issues/196)

---

##  해결되지 않은 질문들

# Q. 만일 어떤 함수가 단지 값을 리턴하기만 하는 순수함수인데 그 리턴된 값이 어느곳에서도 사용되지 않았다면 그 함수는 애초에 호출할 필요가 없는 함수였다. 이같은 상황에서 자바스크립트 컴파일러는 함수를 호출하지 않도록 최적화를 수행할 수 있는가 ?\
A. [참고](https://stackoverflow.com/questions/62011982/does-javascript-v8-optimizes-unused-return-values)

# Q. 자바스크립트에는 심볼이라는 기능이 있는데 정확히 이게 왜 필요한가 ?

# Q. 자바스크립트의 객체는 딕셔너리 구조로 되어있다.  다른말로 객체는 맵(Map)과 같다. 그런데도 자바스크립트에는 맵이 따로 구현되어 있다. 이미 맵과 거의 유사한 객체라는 개념이 있는데 왜 굳이 맵을 별도로 구현하였는가 ?
https://stackoverflow.com/questions/18541940/map-vs-object-in-javascript
https://stackoverflow.com/questions/32600157/maps-vs-objects-in-es6-when-to-use


# Q. js에는 set이라는 자료구조가 있는데 이건 언제 사용하는건가 ?

# Q. `javascript:void(0);`이 무슨 뜻인가 ?

# Q . 오픈소스에서 `void 0` 라고 표기하는 경우가 보이는데 이건 무슨 뜻인가 ?;


# Q. Object.toString.call()과 Object.prototype.toString.call()은 값이 다르다. 왜 그런가?
