# programming typescript (오레일리) 요약

## 챕터 1. ts 소개
ts의 가장 큰 장점은 컴파일시에 에러를 던진다는 점이다  
아래 코드는 js에서 정상작동하지만 ts에서는 컴파일시 오류가 발생한다
```
3 + [] // error TS2365: Operator '+' cannot be applied to types 'number' and 'undefined[]'.
```
연산자 실행시 피연산자를 확인하고 연산에 적합하지 않다고 판단하면 에러를 던진다
```dotnetcli
(function _2로나누기(b) {return b / 2})("문자열") // error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
```
연산자 실행시 피연산자를 확인하고 연산에 적합하지 않다고 판단하면 에러를 던진다

```
let obj = {}
obj.없는프로퍼티 // error TS2339: Property '없는프로퍼티' does not exist on type '{}'.
```
js에서 위 코드의 `obj.없는프로퍼티`를 참조하면 `undefined`를 리턴하지만 ts는 컴파일시에 에러를 던진다

## 챕터 2. overview

### 2.1 컴파일러  
tsc는 타입스크립트 컴파일러이며 ts파일을 js로 변환한다  
컴파일 도중 타입을 검사하여 타입관련 오류가 발생하면 js로 변환하지 않는다  

### 2.2 타입 시스템  

#### 2.2.1 ts vs js
별 내용 없음  

### 2.3 코드 편집기 설정
tsconfig.json  설정방법을 알려준다
tslint.json  설정방법을 알려준다

### 2.4 index.ts
별 내용 없음  

## 챕터 3. 타입
### 3.1 타입을 이야기하다
타입 어노테이션에 대하여 : 타입 어노테이션이 지정된 변수는 명시된 타입 이하의 타입만 할당할수 있다

### 3.2 타입의 가나다
#### 3.2.1 any
any를 사용하면 ts의 타입 검사기가 작동하지 않는다. 따라서 any는 사용하지 않는 편이 좋다

#### 3.2.2 unknown
unknown은 `if(typeof a === 'number')`와 같이 타입이 확정되기 전까지는 사용이 불가능하다

#### 3.2.3 boolean

### 3.3 마치며
별 내용 없음  

## 챕터 4. 함수  

### 4.1 함수 선언과 호출
보통 함수 매개변수 타입은 명시적으로 정의한다  
리턴 타입은 ts가 반환 타입을 추론하도록 하는게 기본이다  

#### 4.1.1 선택적 매개변수 & 기본 매개변수
변수명 뒤에 `?` 를 붙이면 optional parameters가 된다  

#### 4.1.2 rest parameters
함수가 가변인자로 호출될 때 `...`으로 표기되는 rest parameters 기능을 쓰면 인자들을 하나의 배열로 처리할수 있다. 이 기능은 ts기능은 아니지만 알아두면 유용하다
```
function n개더하기(...숫자들 : number[]) : number {
    return 숫자들.reduce((총합, 수) => 총합 + 수 , 0)
 }

console.log(n개더하기(1,2,3))
```

#### 4.1.3 call, apply, bind
js내용이다

#### 4.1.4 this의 타입
this를 쓸일이 없으므로 넘어간다

#### 4.1.5 제네레이터
js 내용이다

#### 4.1.6 iterator & iterable
js 내용이다  

#### 4.1.7 호출 시그니처
다음과 같은 함수가 있다
```dotnetcli
const 더하기 = (a:number, b: number) : number => a + b
```
위의 함수의 호출 시그니처 또는 타입 시그니처는 아래와 같다  
`(a:number, b:number) => number`
위의 호출 시그니처를 적용하면 아래와 같이 쓸 수 있다
```dotnetcli
type 더하기시그니처 = (a:number, b:number) => number
const 더하기 : 더하기시그니처 = (a, b) => a + b
console.log(더하기(1,2));
```
타입 시그니처를 다른 파일에 정의하고 임포트하는 패턴이 일반적이다. 아래와 같다
```dotnetcli
import {더하기시그니처} from './ch.4.type'
const 더하기 : 더하기시그니처 = (a, b) => a + b
console.log(더하기(1,2));
```

#### 4.1.8 contextual typing  
contextual typing은 강력한 타입추론 기능이다  
특정 함수가 함수 f를 인자로 받을때, 함수 f가 이미 타입 시그니처로 정의되어 있으면 전달하는 함수의 타입을 명시할 필요가 없다. 타입 시그니처라는 문맥을 보고 인자의 타입을 추론하기 때문이다  


#### 4.1.9 오버로드된 함수 타입  
같은 이름의 함수 시그니처가 여러개 있는 함수를 overloaded function이라고 한다
만일 오버로드된 함수 타입을 타입으로 사용한다면 함수에 타입을 다시 선언하자. 그래야 자동완성 기능의 혜택을 볼수있다.
예를들어
```dotnetcli
let 예약 : 예약타입 = (
    시작일 : Date
    종료일 : Date
    예약지? : string
) => {
}
```
이와같이 예약타입으로 타입을 명시했지만 오버로드된 함수 타입이므로 정확한 타입을 확정할 수 없을 때에는 타입을 다시 선언해주어야 자동완성 기능의 혜택을 볼수 있다.

### 4.2 다형성 (제네릭)
제네릭은 제네릭 매개변수의 줄임말이다  
꺽쇠괄호로 시작하는 문법을 제네릭이라고 한다. 알파벳 대문자로 표기하는게 일반적이다  
제네릭은 타입을 특정할 수 없는 상황에서 n개의 타입 중의 어느 하나라는 불확정한 타입을 표현할 때 사용한다  
이것은 지시대명사 `this, that` 또는 한국어에 `거시기`에 가까운 문법이다  
제네릭은 함수 시그니처의 맨 앞에 붙이면 된다. 예를들어 아래와 같다  
`<T>(배열 : T[]) => T[]`  
위의 함수 시그니처는 임의의 타입 T의 배열을 인자로 받아 T 타입의 배열을 리턴한다  

### 4.3 타입 주도 개발  
함수의 타입 시그니처를 먼저 선언하고 함수를 구현하는 개발을 type-driven development라고 부른다  

### 4.4 마치며  
별 내용 없음

## 챕터 5. 클래스 & 인터페이스
ts는 클래스 멤버에 3가지 접근 권한을 설정할 수 있다. 이는 자바와 같다
`public, private, protected`  
아무것도 선언하지 않았을 때는 기본값으로 public이 선언된다

abstract 클래스를 선언하면 해당 클래스로는 직접 생성자를 통해 인스턴스를 생성할 수 없다
absctract 키워드는 해당 클래스를 바로 인스턴스화 할 수 없음을 의미한다.  
abstract 클래스를 활용하려면 반드시 해당 클래스를 상속받은 자식 클래스가 abstract를 구현해야 한다.
### 5.1 클래스와 상속

### 5.2 super

### 5.3 this를 반환 타입으로 사용하기

### 5.4 인터페이스
인터페이스는 type alias와 개념적으로는 같다. 인터페이스는 클래스에 지정하는 type alias라고 이해해도 문제될 건 없지만 타입과 인터페이스는 3가지 면에서 차이가 있다
1. 인터페이스의 정의에는 반드시 타입 표현식을 쓸 수 없다. 예를들어 `다른타입 , &, |` 등의 문법을 쓸 수 없다
1. 인터페이스가 인터페이스를 상속하고 메소드를 오버라이딩 할 때  상위 인터페이스와 정의가 충돌되는지 확인하고 만일 정의가 충돌하면 에러를 던진다  
1. 이름이 같은 인터페이스가 여러개 있으면 이들이 자동으로 합쳐진다. 이를 declaration merging 선언 합침이라고 부른다  

인터페이스는 static 키워드를 사용할 수 없다  
인터페이스는 private, public, protected등의 접근 제한자를 사용할 수 없다  

#### 5.4.1 인터페이스의 declaration merging (선언 합침)
이름이 같은 인터페이스가 여러개 정의되었으면 하나로 합쳐진다. 유니온 타입으로 합쳐지는게 아니라 하나의 단일 타입으로 합쳐진다

#### 5.4.2 인터페이스의 implements
하나의 클래스는 2개 이상의 인터페이스를 implements할 수 있다. 하지만 인터페이스와는 달리 2개 이상의 클래스는 상속할 수 없다.

#### 5.4.3 인터페이스 구현 vs 추상 클래스 상속
인터페이스와 추상 클래스는 개념적으로 유사하다
추상 클래스는 생성자를 가질 수 있다  
추상 클래스는 기본 구현을 가질 수 있다.
추상 클래스는 private, public, protected등의 접근 한정자를 지정할 수 있다
이 책에는 어떤 상황에서 각각 인터페이스, 추상 클래스를 사용하라는 구체적인 지침은 없다

### 5.5 클래스는 구조 기반 타입을 지원한다
클래스가 다른 함수의 인자로 들어갈 때 정확히 그 클래스일 필요는 없다
ts는 구조를 기반으로 타입을 체크하므로 구조적으로만 일치하면 된다  
예를들어 2개의 클래스가 있고 메소드명이 정확히 일치한다면 이 두개의 클래스는 구조적으로 일치한다.  

### 5.6 클래스는 값과 타입을 모두 선언한다

### 5.7 다형성

### 5.8 믹스인

### 5.9 데코레이터

### 5.10 final 클래스 흉내내기

### 5.11 디자인 패턴

### 5.12 마치며

연습 문제

## 챕터 6. 타입의 고급주제

### 6.1 타입 간의 관계

#### 6.1.1 서브타입 & 슈퍼타입  

#### 6.1.2 가변성 (variance)  

##### 6.1.2.1  객체 & 배열의 가변성

##### 6.1.2.2  함수 가변성

#### 6.1.3 할당성
할당할 수 있는가 없는가를 결정짓는 방식  
`A <: B` 즉 A가 B의 서브타입입이면 B가 할당되는 곳에서 A도 할당할 수 있다  

#### 6.1.4 타입 넒히기 (type widening)
`let 문자열 = 'asdf'` 를 입력하면 문자열 변수는 리터럴 값이 속한 기본 타입으로 넒혀진다  

##### 6.1.4.2 excess property checking
ts에서는 인자가 신선한 인자일 때 초과 프로퍼티 체킹을 수행한다. 만일 신선한 인자가 초과 프로퍼티를 가지고 있으면 에러로 처리된다. 구체적인 규칙은 아래와 같다
1. 신선한 객체는 초과 프로퍼티 체킹의 대상이다  
1. 어서션된 타입은 초과 프로퍼티의 체킹의 대상이 아니다. 어서션이란 타입 체킹을 피하려고 만든 기능이기 때문이다.
1. 미리 변수에 할당된 값은 신선한 객체가 아니다. 따라서 초과 프로퍼티 체킹을 수행하지 않는다.
1. 신선한 객체가 아니더라도 타입이 명시된 변수는 초과 프로퍼티 체킹의 대상이다.

#### 6.1.5 refinement (정제)
ts는 흐름기반 타입 추론을 수행한다. 다시말해 if문으로 타입이 확정된 상황에서는 타입의 범위를 좁힌다

##### 6.1.5.1 discriminated union type  
인자가 유니온 타입일때 주의할 점이 있다. 인자가 유니온의 어떤 타입에 해당하는지를 확실하게 판단할 수 있어야 한다. refinement를 사용할 때 객체의 어떤 프로퍼티를 검사하는지에 따라 이 refinement가 제대로 수행될 수도 있고 제대로 수행되지 않을 수도 있다.

### 6.2 totality(종합성)
함수 시그니처의 리턴타입에 명시된 모든 경우의 수가 제대로 리턴되었는지 체크하는 기능이다  

### 6.3 고급 객체 타입

#### 6.3.1 객체 타입의 타입 연산자 (key-in)  
##### 6.3.1.1 key-in  
`key-in`은 객체 타입을 쪼개서 또다른 객체 타입을 만드는 편리한 기능이다.  

##### 6.3.1.2 key of
`key of`는 객체의 모든 키를 유니온 타입으로 리턴하는 기능이다  

#### 6.3.2 Record 타입
Record는 내장된 객체 타입이다. Record안에는 제네릭으로 추가된 타입의 모든 타입이 객체에 전부 다 표기되어 있어야 한다

#### 6.3.3 mapped type

#### 6.3.4 컴패니언 객체 패턴
타입과 객체를 같은 변수로 취급할 수 있는 기능이다  
### 6.4 고급 함수 타입들

#### 6.4.1 튜플의 타입 추론 개선
엄격한 튜플 타입을 지정하려면 타입 어서션을 사용해도 괜찮지만 rest parameters 문법 `...[1,2,3]` 을 이용할 수도 있다

#### 6.4.2 사용자 정의 타입의 안전장치
type refinement는 현재 스코프 내에서먄 유효하다. 만일 type refinement이후 리턴하여 스코프가 바뀌면 해당 refinement를 이용한 에러 패싱 기능이 작동하지 않는다.  
user-defined type guard기능을 사용하면 스코프가 바뀌어도 type refinement기능을 수행할 수 있다.
```
function 문자열체크(a:unknown) : a is string{
    return typeof a === 'string'
}
```
위의 코드에서 리턴된 a는 string으로 type refinement 기능이 적용된다  

### 6.5 조건부 타입 (conditional type)
타입을 지정할 때 상황에 따라서 다른 타입을 지정할 수 있다
`type IsString<T> = T exntends string ? true : false `  

#### 6.5.1 분배적 조건부 (distributive conditional type)  
T에는 존재하지만 U에는 존재하지 않는 타입을 구하는 방법이다  
삼항 연산자를 사용해서 분배적 조건부 타입을 정의한다
`type Without<T, U> = (T extends U) ? never : T`

#### 6.5.2 infer 키워드
infer는 번역하면 추론인데 말 그대로 타입을 추론하는 기능이다.  
infer키워드는 `T extends U`처럼 클래스 확장 문법과 겸용해서 쓸 수 있다  
`type 어떤타입<T> = T extends (infer U)[] ? U : T`  
위의 코드는 어떤 T가 전달되었는지를 확인하고 거기에 맞추어 U의 타입을 자체적으로 추론한다  

### 6.5.3 내장(built-in) 조건부 타입들
`Exclude(T, U)`  
T에는 속하되 U에는 없는 타입을 구한다

### 6.6 탈출구 (assertion)
타입을 완전하게 지정하지 않고도 이 작업이 안전하다는 사실을 알려줄때 어셔선을 사용한다
``
#### 6.6.1 타입 어서션
```dotnetcli
function 입력함수(입력 : string) {
 // ...
}
입력함수(입력 as string)
```
#### 6.6.2 null이 아니라는 것을 알려주는 어셔선
`document.getElementById('app')!.removeChild(자식엘리먼트)`  
not-null 어서션은 js의 optional chaining과 문법적으로 유사하다.  
다만 `?` 대신 `!`를 사용할 뿐이다  
not-null 어서션은 값이 null일 가능성을 제거한다  

#### 6.6.3 확실한 할당 어서션
변수가 할당되지 않은 상황에서도 할당되었다고 알려주는 어서션이다  
`let 유저아이디! : string`  
느낌표 명령어는 어서션과 관련된게 많다
### 6.7 이름 기반 타입 흉내내기
ts는 구조 기반 타입 검사기이지만 이름 기반 타입을 흉내내야 할 때가 있다.
이름 기반 타입은 어서션 기능으로 구현할 수 있다.  

```dotnetcli
function 유저아이디함수(아이디 : string) {return 아이디 as UserID}
function 회사아이디함수(아이디 : string) {return 아이디 as CompanyID}
function 유저쿼리(아이디 : UserID){
   // ...
}

// 아래 호출은 정상작동
let 유저아이디 = 유저아이디함수('12345')
유저쿼리(유저아이디) // 정상작동

// 아래 호출은 타입이 다르므로 에러를 발생
let 회사아이디 = 회사아이디함수('12345')
유저쿼리(회사아이디) // 에러발생 : CompanyID 타입의 인수를 UserID 타입의 매개변수에 할당할 수 없음

```
### 6.8 프로토타입 메소드를 안전하게 추가하기
`Array.prototype.zip` 같은 프로토타입 메소드를 안전하게 추가하는 방법을 설명함  

### 6.9 마치며
별 내용 없음  

## 챕터 7. 에러 처리

### 7.1 null 반환  

null을 리턴하면 어떤 종류의 에러인지 확인할 수 없다

### 7.2 예외 던지기  
예외를 throw하면 catch 구문에서 받아 어떤 에러인지 명시할 수 있다  

### 7.3 예외 반환
예외를 리턴하면 실행흐름을 바꾸지 않고도 리턴후에 어떤 종류의 에러인지 확인할 수 있다  
에러를 리턴했을 때는 모든 에러에 대한 상황을 if문으로 처리해야 하며 if문으로 처리하지 않은 경우 에러를 발생한다

### 7.4 Option 타입  
Option 타입은 Maybe 타입이라고도 불리며 컨테이너 타입이라고도 불린다.
Option 타입은 함수 파이프라인 또는 메소드 체이닝을 할때 중간에 null을 만나도 에러를 발생하지 않고 연쇄적으로 처리할 수 있게 해준다  
옵션 타입은 ts내장 타입이 아니며 개발자가 하나의 함수를 여러번 오버로딩해서 여러가지 경우의 수를 직접 명시해야 한다

### 7.5 마치며

연습 문제

## 챕터 8. 비동기 프로그래밍

### 8.1 자바스크립트의 이벤트 루프

### 8.2 콜백 사용하기  

### 8.3 프로미스로 정상 회복하기  

### 8.4 async와 await  

### 8.5 비동기 스트림  

### 8.6 타입 안전 멀티스레딩  

### 8.7 마치며

## 챕터 9. FE프레임워크 , 백앤드 프레임워크

### 9.1 프론트엔드 프레임워크

### 9.2 타입 안전  

### 9.3 백엔드 프레임워크

### 9.4 마치며

##  챕터 10. 모듈

###  10.1 가볍게 살펴보는 자바스크립트 모듈의 역사

###  10.2 import, export

###  10.3 네임스페이스

###  10.4 선언 합치기

###  10.5 마치며

## 챕터 11. js와의 interop

###  11.1 타입 선언

###  11.2 자바스크립트를 타입스크립트로 천천히 마이그레이션하기

###  11.3 자바스크립트의 타입 검색

###  11.4 서드 파티 자바스크립트 사용

###  11.5 마치며

## 챕터 12. ts 빌드하기

###  12.1 타입스크립트 프로젝트 빌드하기

###  12.2 서버에서 타입스크립트 실행

###  12.3 브라우저에서 타입스크립트 실행

###  12.4 타입스크립트 코드를 NPM으로 발행하기

###  12.5 세 슬래시 지시어

###  12.6 마치며

## 챕터 13. 결론

## 부록 A 타입 연산자

## 부록 B 타입 유틸리티

## 부록 C 영역을 갖는 선언

## 부록 D 서드 파티 자바스크립트 모듈용 선언 파일 구현 기법

## 부록 E 세 슬래시 지시어

## 부록 F 안정성과 관련된 TSC 컴파일러 플래그

## 부록 G TSX
